#summary FPGA implementation notes
#labels Phase-Design,Featured

= Clock distribution =

[http://vector06cc.googlecode.com/svn/trunk/doc/clocks.png]

Clock distribution:
 * clk24 is the master clock, also VGA pixel clock 
 * ce12 (12MHz) is 512 pixel mode pixel clock (PAL)
 * ce6 (6MHz) is the pixel/ram address clock
 * ce3 (3MHz) this is the main CPU clock enable
 * ce3v (3MHz) is unused --> floppy CPU boohoo
 * video_slice is high when video adapter wants RAM
 * pipe_ab is an internal signal in the video controller, invisible in this short simulation
 * timer_vi53_ce is the slow 1.5MHz clock enable for 8253 soundnik

= Keyboard =
In this implementation an attempt is made to make the keyboard as accessible to the modern user as possible, while keeping the impact on compatibility minimal. A complex interface maps PS/2 keyboard codes into Vector-06C keyboard matrix, while keeping track of both PS/2 and Vector Shift status. This results in smooth interaction with modern keyboards, the user doesn't need to know where certain characters were located on the original keyboard at all. One drawback is Cyrillic keyboard layout, which is currently not mapped out. This may also cause problems in programs that assume the keyboard geometry to be fixed, e.g. piano keys simulators. Such functionality can be added: see [http://code.google.com/p/vector06cc/issues/detail?id=10 related issue].

Keyboard interface consists of low level PS/2 driver located in ps2k.v, scancode converter roms in scan2matrix.v and toplevel interface with matrix encoder in vectorkeys.v. 

PS/2 driver, `ps2k.v` is very basic and provides no possibility to send commands to the keyboard, e.g. to set typematic rate or change the status of keyboard LED's. The main module is `vectorkeys.v`. The state machine there handles make and release codes, while keeping track on natural, forced and negated shifts. This is necessary to properly implement keys that have different shift status on different keyboards, e.g. to enter a ':' one presses ':' key on the original Vector without Shift, while on a PS/2 one normally presses Shift+; to enter a ':'. Thus, a shift has to be neglected from the keyboard matrix. Same ':' key with shift on Vector would enter an asterisk, '{{{*}}}'. On a PS/2 keyboard, asterisk is entered by pressing Shift+8, thus the shift status is kept natural for "Shift+8". Other interesting case of shift handling is dictated by the PS/2 keyboard itself which sends make shift code before each grey arrow keypress and break shift code after it's released.

The matrix itself is simulated rather physically, see `rowbits` assignment in `vectorkeys.v`. This ensures proper emulation but, of course, is far from being compact or elegant. Ideally, keymatrix should be made a RAM block and rowbits would then be updated sequentially. Unfortunately, to make this possible, the main state machine with all logic would have to be slightly rewritten.

See also: [http://www.quadibloc.com/comp/scan.htm Scan Codes Demystified]

= Mock Disk (kvaz, квазидиск) =

Same SRAM chip is used for main memory and for the RAM disk. The complete memory map can be laid out approximately like this (addresses given in byte mode, divide by 2 for physical figures):
||00000||Main RAM||
||10000||Ramdisk page 0||
||20000||Ramdisk page 1||
||30000||Ramdisk page 2||
||40000||Ramdisk page 3||

Important signals in the toplevel:
 * `ramdisk_control_write` ramdisk control register select, port $10 (write-only)
 * `io_stack` stack I/O selector
 * `ramdisk_page` bits [16:15] of external SRAM bus, fed into `sram_map`

`kvaz` is basically just another level of SRAM multiplexer. Its mode of operation is controlled by the ramdisk control register. Depending on configuration, it would select SRAM page, bits [16:15] of external SRAM address bus, during regular memory access (in window mode) or stack access (in stack mode). Output `ramdisk_page` is then fed through to `sram_map` module where it's joined into the complete SRAM address.

See also: [ramdisk Описание функционирования квазидиска], [JTAG_Implementation].

= Floppy Drive =
_This section describes work in progress_

== Theory (Fantasy) ==
=== Overview ===
The floppy drive system is being implemented as a separate entity based on a 6502 CPU. M4K blocks are used for memory, namely 24576 bytes of main ram + 256 bytes of zero page and stack ram. According to Quartus report, 201984 memory bits are used, which is 84% of the device on DE1 and which is most likely unacceptable. 

The code that lives in the 6502 unit is written in C and compiled by [http://www.cc65.org cc65] compiler. C language library, crt0.s and linker configuration file, vector.lc, are provided. Architecture is mostly defined by vector.lc file which contains memory map and specialio.h, which defines I/O locations. It seems that for succesful operation, memory size 1 byte smaller than real should be specified -- ~~must~~ could be investigated. 

=== Code size concerns ===
FAT support is based on Elm-Chan's awesome [http://elm-chan.org/fsw/ff/00index_e.html Generic FAT Filesystem module]. This module is the best one can ever wish for, providing most everything out of the box. However, being exceptionally robust, it's also not tiny.

cc65 produces some fat code, although knowing the 6502, cc65 is probably not to be blamed. On a positive note, it's a fully functional _real_ C and not some fake paw mockup. Complete code probably will NOT fit in 16K and that would change the design dramatically, requiring access to SRAM and a fetch of full-fledged ROM-image from the SD card by a smaller ROM-image.

=== WD1793 ===
Vector used a Russki clone of WD1793 floppy drive controller. It is called so because the design originates from Marie Antoinette, for which she was guillotined in 1793.
 * [http://www.hansotten.com/msxwd1793.html MSX Info Pages of WD1793]
 * [http://svn.akop.org/psp/trunk/fms/EMULib/ EMULib has C-source of the WD1793 emulator]
 * [http://elm-chan.org/docs/mmc/mmc_e.html ELM: How to MMC/SD]
 * [http://elm-chan.org/fsw/ff/00index_e.html Generic FAT Filesystem module]
Also see Technical_Description for Vector-06C port map, [VectorSecrets_by_Lebedev Секреты Вектора от Лебедева] and [SVK1_Floppy Секреты Вектора и Кристы]

== Practice ==

=== Preliminary HW layer tests ===
[http://vector06cc.googlecode.com/svn/trunk/doc/wd-clocks-preliminarytest.png]
Test simulation run of the HW layer. The "program" being executed here would be roughly:
{{{
 RESET (as in hw pin)
 
 RESTORE:     (0)=0F
 TRACK:       (1)=12
 SEEK:        (0)=1F
 STEPF:       (0)=4F (no update)
 STEP:        (0)=3F (previous direction, update)
 READ STATUS ==> 22
 SECTOR:      (2)=03
 READADDR:    (0)=C0 
   -> CPU command issued
   <- CPU completion status set
   -> CPU "ACK" command issued
   DRQ set
 READ STATUS ==> 03
 READ DATA
 READ DATA
 ...
}}}
 
Remarks:
 * ~~Buffer read takes 2 clocks as opposed to single-clock operation for everything else~~ not anymore
 * 9ns is about minimal required settle time for `idata`

=== CPU Requests ===
||`CPU_REQUEST_READ` || 8'h10 || Request to read one sector at `oTRACK`, `oSECTOR`, bit 0 is side (head #) ||
||`CPU_REQUEST_WRITE`||8'h20 ||  Request to write one sector at `oTRACK`, `oSECTOR`; bit 0 is side (head #) ||
||`CPU_REQUEST_READADDR` || 8'h30|| Request to read sector address (return 6 byte header) ||
||`CPU_REQUEST_ACK`|| 8'h80|| Acknowledge: clear CPU status bits ||

After CPU has done with processing any request other than `CPU_REQUEST_ACK`, it sets two bits in `iCPU_STATUS`:
 * bit 0 == 1: operation complete
 * bit 1 == 1: operation was successful

=== CPU I/O Ports ===
Ports start at memory location $E000:
||E000||MMC_A: bit0 = SD_DAT3/CS||
||E001||SPDR: SPI data register, same as in AVR||
||E002||SPSR: SPI status register, only SPIF (bit 0) is implemented||
||E003||reserved||
||E004||TxD||
||E005||RxD (not implemented)||
||E006||SERIAL_CTL (status, bit 0 == busy)||
||E007||10mS timer/counter 1||
||E008||10mS timer/counter 2||
||E009||CPU_REQUEST (bit 0 == side) request port, polled||
||E00A||CPU_STATUS (write-only) return status here||
||E00B||TRACK (read-only) track index from the hardware||
||EOOC||SECTOR (read-only) sector index from the hardware||
||E010||GLEDS green leds||